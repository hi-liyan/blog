---
id: transaction
title: 浅谈 Transaction 事务
---
import RightAngleBadge from "../../src/components/RightAngleBadge";

## 1. 事务的 ACID 原则




<br/>

## 2. 数据库并发操作产生的问题

<br/>

### 2.1 产生的问题

<br/>

### 2.2 事物的隔离级别

|事物隔离级别|脏读|不可重复度|幻读|
|---|---|---|---|
|READ_UNCOMMITTED|允许|允许|允许|
|READ_COMMITTED|禁止|允许|允许|
|REPEATABLE_READ|禁止|禁止|允许|
|SERIALIZABLE|禁止|禁止|禁止|

<br/>

## 3. Spring 中7种事务传播行为

Spring 提供了 7 种事务传播行为：（这几个单词的直译就能体现它们的作用）

- Propagation.REQUIRED 当前方法**必须**以事务方式执行
- Propagation.SUPPORTS 当前方法**支持**其它方法的决定
- Propagation.MANDATORY 当前方法**强制**其它方法必须以事务方式执行
- Propagation.REQUIRES_NEW 当前方法**需要**以一个新的事务执行，并且执行时会挂起其它事务
- Propagation.NOT_SUPPORTED 当前方法**不支持**事务方式执行
- Propagation.NEVER 当前方法**绝不可能**以事务方式执行，也不允许其它方法以事务方式执行
- Propagation.NESTED 当前方法作为一个子事务**嵌套**在其他事务中，提交还是回滚受其它事务影响

:::tip
在 SpringBoot 项目中，通常使用 `@Transactional` 注解为方法添加事务，通过注解的 `propagation` 属性（如：@Transactional(propagation = Propagation.REQUIRED) ）可以设置事务的传播行为。
:::

:::caution
事务的传播行为是作用于两个类的方法之间的，为什么是两个类之间？同一个类中的两个方法不行？这个问题留到后面再说。
:::

<br/>

### 3.1 Propagation.REQUIRED

<RightAngleBadge>表示当前方法必须以事务方式执行。</RightAngleBadge>

如果是当前方法调用其它方法，当前方法必须以事务方式执行，其它方法的行为要看其它方法的事务传播行为是如何设置的：

- 例如被调用的方法没有事务，或者被调用方法是 Propagation.REQUIRED 或者 Propagation.SUPPORTS 等，这些不冲突的情况其他方法都会加入到当前方法的事务中，在同一个事务中执行，发生异常，所有操作都会回滚；
- 如果被调用方法是 `Propagation.REQUIRES_NEW` 或者 `Propagation.NEVER` 这种就不会加入到当前方法的事务中，前者会起一个新的事务执行，后者会直接抛异常，因为它不允许其它方法以事务方式执行。 

如果当前方法是被调用方法，调用者没有事务的情况下，只有当前方法会以事务方式执行，调用者因为没有事务所以不会以事务方式执行。如果调用者存在事务，还要看它的事务传播行为是如何定义的。

:::tip
Propagation.REQUIRED 是 Spring 中默认的传播行为，也满足大多数使用场景。
:::

<br/>

### 3.2 Propagation.SUPPORTS

<RightAngleBadge>表示当前方法支持其他方法的决定，但本身不以事务执行</RightAngleBadge>

如果调用它的方法是 Propagation.REQUIRED，则它会加入到调用者的事务中；

如果其它方法是 Propagation.MANDATORY，则会抛出异常，因为 Propagation.MANDATORY 要求其它方法必须以事务方式执行；

如果其它方法是 Propagation.NEVER 也不会抛异常。


<br/>

### 3.3 Propagation.MANDATORY

<RightAngleBadge>当前方法以事务方式执行，并强制调用它的方法也以事务方式执行。</RightAngleBadge>

强制要求当前方法的调用者以事务方式执行，并加入到调用者的事务中，即便调用者是 Propagation.REQUIRES_NEW，也会在同一个事务中执行，有一个方法发生异常，所有操作都会回滚；如果调用者不以事务执行，则会抛异常。

如果当前方法作为调用者调用其它方法，也会抛出异常。从代码执行顺序来看，先执行当前方法，发现传播行为是 Propagation.MANDATORY，就会在当前事务中找其它方法的事务，发现事务上下文中只有 MANDATORY，所以抛异常了。

<br/>

### 3.4 Propagation.REQUIRES_NEW

方法B 的事务传播行为设置为：`Propagation.REQUIRES_NEW`，那么，方法B 会创建一个新的事务：

- 如果方法A 存在事务，当执行到方法B 时，方法A 的事务会被挂起，当方法B 的事务执行结束后，继续执行方法A 的事务：
  - 如果方法B 发生异常，则方法B 的事务会回滚数据，异常抛到方法A 时方法A 在没有捕获异常的情况下也会回滚数据；
  - 如果方法A 发生异常，则方法A 会回滚，方法B 不会回滚，因为方法B 的事务已经执行完了。
- 如果方法A 不存在事务，方法A 不以事务方式执行。当方法A 发生异常时，不会回滚数据。

<br/>

### 3.5 Propagation.NOT_SUPPORTED

方法B 的事务传播行为设置为：`Propagation.NOT_SUPPORTED`，那么，方法B 不支持事务：

- 如果方法A 存在事务，当执行到方法B 时，方法A 的事务会被挂起，方法B 以非事务方式执行，当方法B 执行结束后，继续执行方法A 的事务。方法B 发生异常也不会回滚，异常抛到方法A 时方法A 在没有捕获异常的情况下会回滚；
- 如果方法A 不存在事务，方法A 不以事务方式执行。当方法A 发生异常时，不会回滚数据。

<br/>

### 3.6 Propagation.NEVER

方法B 的事务传播行为设置为：`Propagation.NEVER`，那么，方法从不会以事务方式执行：

- 如果方法A 存在事务，则抛出异常；
- 如果方法A 不存在事务，方法A 和 B 都不会以事务方式执行。

<br/>

### 3.7 Propagation.NESTED

方法B 的事务传播行为设置为：`Propagation.NESTED`，那么，：

- 如果方法A 存在事务，方法B 会创建一个当前事务的**子事务**，当执行到方法B 时，方法A 的事务会被挂起，然后执行这个方法B 这个子事务，当方法B 这个子事务执行结束后，继续执行方法A 的事务：
  - 如果方法B 这个子事务发生异常回滚数据，异常抛到方法A 时方法A 在没有捕获异常的情况下也会回滚数据；
  - 如果方法A 发生异常回滚数据，方法B 这个子事务也会回滚数据。
- 如果方法A 不存在事务，方法A 不以事务方式执行。当方法A 发生异常时，不会回滚数据。


<br/>


### 3.8 注意事项

以上是对 Spring 中的 7 种事务传播行为的介绍，最常用也是默认的方式是第一种 `Propagation.REQUIRED`，适合绝大多数场景，如果有特殊需求可以回头来看看其它几种方式。

下面说一下注意事项：

首先，上面已经提到了事务的传播方向，**它是从被调用者往调用者方向传，以被调用者为圆心往外传播，也就是说，被调用者设置某种传播行为，导致调用者和被调用者产生什么行为的这种因果关系。所以说，上面的这 7 中传播行为都是以此为基础的**。为什么这里又重申了一遍呢？因为我在网上看其它文章的评论时，发现很多小伙伴以为是调用者设置了传播行为，导致被调用产生什么行为，这是不正确的，因为你会发现，越往下看越理解不通。

还有一种情况是，正向传播，假设方法A 调用方法B，方法A 有事务，方法B 没有事务，这种情况下方法A 和 B 都会在同一个事务中执行，发生异常都会回滚数据。但凡方法B 有事务，那么方法A 就要遵循上面的 7 中传播行为。

第二要说的是，上面所说的事务的传播行为都是发生在两个类之间的方法调用，因为 Spring 中的事务是通过代理来实现事务行为的。如果是发生在同一个类中的两个事务方法调用，一个代理没有办法为同一个类中的两个方法添加（扩展）不同的行为，无论是 Jdk 提供的基于接口的代理，还是 CGLib 实现的基于子类的代理，所以可能出现两个方法的事务都不生效的情况。


<br/>

:::tip
额外说下 `@Transactional` 的使用事项：

- 被注解的方法必须是 public 修饰；
- 该注解默认是 RuntimeException 异常才回滚，一般可以通过 `@Transactional(rollbackFor = Exception.class)` 指定回滚的异常；
- 方法中不能使用 try-catch 捕获异常，否则注解不生效，必须抛出异常;
- 同一个类中的两个方法之间调用时，事务传播行为可能会导致事务失效。假设一个类中方法A 调用方法B， 方法B 有事务默认`Propagation.REQUIRED`，但方法A 没有事务，理论上方法B 在发生异常时会回滚方法B 的操作，但实际方法B 的事务也没有生效。
:::