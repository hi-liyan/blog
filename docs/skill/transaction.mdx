---
id: transaction
title: 浅谈 Transaction 事务
---

## 1. 事务的 ACID 原则




<br/>

## 2. 数据库并发操作产生的问题

<br/>

### 2.1 产生的问题

<br/>

### 2.2 事物的隔离级别

|事物隔离级别|脏读|不可重复度|幻读|
|---|---|---|---|
|READ_UNCOMMITTED|允许|允许|允许|
|READ_COMMITTED|禁止|允许|允许|
|REPEATABLE_READ|禁止|禁止|允许|
|SERIALIZABLE|禁止|禁止|禁止|

<br/>

## 3. Spring 中7种事务传播行为

事务的传播行为在平日开发中用到比较少，大多数情况都使用默认的设置，但如果想了解 Spring 提供的这 7 种事务传播行为，要讲的东西还真不少，看了网上的多篇文章对其介绍的很生硬，所以我再重新介绍下 Spring 中的这 7 种事务的传播行为，看看不同的传播行为会导致什么样的结果。*（废话不多说，接着往下瞧...）*

首先，需要先清楚一个概念，那就是**事务的传播方向**，传播方向可以是**正向**的（调用者->被调用者），也可以是**逆向**的（被调用者->调用者）。


一个方法设置了事务（默认的传播行为 `Propagation.REQUIRED`），该事务传播方向是往调用它的方法传播（调用者 <- 设置了传播行为的方法），也就是逆向传播。在某种程度约束了该方法的调用者。假设方法A 调用方法B ，方法B 设置了传播行为，受控的是方法A ，以下的介绍也都是以这个为前提：


*在 SpringBoot 项目中，通常使用 `@Transactional` 注解为方法添加事务，通过注解的 `propagation` 属性（如：@Transactional(propagation = Propagation.REQUIRED) ）可以设置事务的传播行为。*

<br/>


### 3.1 Propagation.REQUIRED

方法B 的事务传播行为设置为 `Propagation.REQUIRED` ，那么：

- 如果方法A 存在事务，则方法B 不新建事务，而是加入到方法A 的事务中，方法A 或B 任何一个发生异常，事务都会回滚；
- 如果方法A 不存在事务，则方法B 新建一个事务，而方法A 不以事务方式执行。方法B 发生异常会回滚当前事务，方法A 发生异常不会回滚其数据库操作。


:::tip
Propagation.REQUIRED 是 Spring 中默认的传播行为，也满足大多数使用场景。
:::


<br/>

### 3.2 Propagation.SUPPORTS

方法B 的事务传播行为设置为 `Propagation.SUPPORTS`，那么：

- 如果方法A 存在事务，则方法B 不新建事务，而是加入到方法A 的事务中，方法A 或B 任何一个发生异常，事务都会回滚；
- 如果方法A 不存在事务，则方法A 和方法B 都不以事务执行，任何一个方法发生异常，都不会回滚数据库操作。

<br/>

### 3.3 Propagation.MANDATORY

方法B 的事务传播行为设置为：`Propagation.MANDATORY`，那么：

- 如果方法A 存在事务，则方法B 不新建事务，而是加入到方法A 的事务中，方法A 或B 任何一个发生异常，事务都会回滚；
- 如果方法A 不存在事务，则抛出异常。

<br/>

### 3.4 Propagation.REQUIRES_NEW

方法B 的事务传播行为设置为：`Propagation.REQUIRES_NEW`，那么，方法B 会创建一个新的事务：

- 如果方法A 存在事务，当执行到方法B 时，方法A 的事务会被挂起，当方法B 的事务执行结束后，继续执行方法A 的事务：
  - 如果方法B 发生异常，则方法B 的事务会回滚数据，异常抛到方法A 时方法A 在没有捕获异常的情况下也会回滚数据；
  - 如果方法A 发生异常，则方法A 会回滚，方法B 不会回滚，因为方法B 的事务已经执行完了。
- 如果方法A 不存在事务，方法A 不以事务方式执行。当方法A 发生异常时，不会回滚数据。

<br/>

### 3.5 Propagation.NOT_SUPPORTED

方法B 的事务传播行为设置为：`Propagation.NOT_SUPPORTED`，那么，方法B 不支持事务：

- 如果方法A 存在事务，当执行到方法B 时，方法A 的事务会被挂起，方法B 以非事务方式执行，当方法B 执行结束后，继续执行方法A 的事务。方法B 发生异常也不会回滚，异常抛到方法A 时方法A 在没有捕获异常的情况下会回滚；
- 如果方法A 不存在事务，方法A 不以事务方式执行。当方法A 发生异常时，不会回滚数据。

<br/>

### 3.6 Propagation.NEVER

方法B 的事务传播行为设置为：`Propagation.NEVER`，那么，方法从不会以事务方式执行：

- 如果方法A 存在事务，则抛出异常；
- 如果方法A 不存在事务，方法A 和 B 都不会以事务方式执行。

<br/>

### 3.7 Propagation.NESTED

方法B 的事务传播行为设置为：`Propagation.NESTED`，那么，：

- 如果方法A 存在事务，方法B 会创建一个当前事务的**子事务**，当执行到方法B 时，方法A 的事务会被挂起，然后执行这个方法B 这个子事务，当方法B 这个子事务执行结束后，继续执行方法A 的事务：
  - 如果方法B 这个子事务发生异常回滚数据，异常抛到方法A 时方法A 在没有捕获异常的情况下也会回滚数据；
  - 如果方法A 发生异常回滚数据，方法B 这个子事务也会回滚数据。
- 如果方法A 不存在事务，方法A 不以事务方式执行。当方法A 发生异常时，不会回滚数据。


<br/>


### 3.8 注意事项

以上是对 Spring 中的 7 种事务传播行为的介绍，最常用也是默认的方式是第一种 `Propagation.REQUIRED`，适合绝大多数场景，如果有特殊需求可以回头来看看其它几种方式。

下面说一下注意事项：

首先，上面已经提到了事务的传播方向，**它是从被调用者往调用者方向传，以被调用者为圆心往外传播，也就是说，被调用者设置某种传播行为，导致调用者和被调用者产生什么行为的这种因果关系。所以说，上面的这 7 中传播行为都是以此为基础的**。为什么这里又重申了一遍呢？因为我在网上看其它文章的评论时，发现很多小伙伴以为是调用者设置了传播行为，导致被调用产生什么行为，这是不正确的，因为你会发现，越往下看越理解不通。

还有一种情况是，正向传播，假设方法A 调用方法B，方法A 有事务，方法B 没有事务，这种情况下方法A 和 B 都会在同一个事务中执行，发生异常都会回滚数据。但凡方法B 有事务，那么方法A 就要遵循上面的 7 中传播行为。

第二要说的是，上面所说的事务的传播行为都是发生在两个类之间的方法调用，因为 Spring 中的事务是通过代理来实现事务行为的。如果是发生在同一个类中的两个事务方法调用，一个代理没有办法为同一个类中的两个方法添加（扩展）不同的行为，无论是 Jdk 提供的基于接口的代理，还是 CGLib 实现的基于子类的代理，所以可能出现两个方法的事务都不生效的情况。


<br/>

:::tip
额外说下 `@Transactional` 的使用事项：

- 被注解的方法必须是 public 修饰；
- 该注解默认是 RuntimeException 异常才回滚，一般可以通过 `@Transactional(rollbackFor = Exception.class)` 指定回滚的异常；
- 方法中不能使用 try-catch 捕获异常，否则注解不生效，必须抛出异常;
- 同一个类中的两个方法之间调用时，事务传播行为可能会导致事务失效。假设一个类中方法A 调用方法B， 方法B 有事务默认`Propagation.REQUIRED`，但方法A 没有事务，理论上方法B 在发生异常时会回滚方法B 的操作，但实际方法B 的事务也没有生效。
:::