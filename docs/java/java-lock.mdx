---
id: java-lock
title: Java 中的锁
---
import TipBox from "../../src/components/TipBox";
import ImgBox from "../../src/components/ImgBox";
import SvgBox from "../../src/components/SvgBox";

<TipBox>
  看了一天关于 Java 锁的内容，越看越迷糊，写篇手记梳理一下。
</TipBox>

## 0. 为什么引入锁

锁是为了解决什么问题？在并发场景下多个线程操作共享资源时，由于读写操作的非原子性，导致数据不一致的问题。为什么说读写是非原子性操作呢？

举例：

类中包含一个静态私有的变量 counter=0，在 main 方法中对 counter 执行一次自增操作。这个自增操作在 Java 代码中看是一条指令，但这一个自增操作编译成字节码后会被分割成多条指令。

```java
public class Demo {
    private static int counter = 0;

    public static void main(String[] args) {
        counter++;
    }
}
```

通过 `javap -c .\Demo.class` 看下编译后的字节码（截取了一部分）：

```
public static void main(java.lang.String[]);
    Code:
       0: getstatic     #2                  // Field counter:I
       3: iconst_1
       4: iadd
       5: putstatic     #2                  // Field counter:I
       8: return
```

从反汇编后的字节码中可以看到，它主要做了以下四步：

1. 获取静态变量 counter 的值；
2. 准备一个常量 1；
3. 加操作；
4. 将运算后的结果放回到静态变量中（重新赋值）

以上这四步完成了一次 counter 的自增操作，但是这个过程是非原子性操作，由于我们使用的操作系统是分时操作系统，假设这是一个并发环境，多个线程对 counter 做自增:

1. 线程A 获取时间片开始执行自增操作，拿到 counter=0，当执行完第三步时，时间片到期了，此时计算后的结果还没有 putstatic；
2. 然后线程B 开始执行，拿到 counter=0，它此时在时间片到期前执行完了自增操作，最后 counter=1；
3. 线程A重新获取时间片，开始接着它上一次执行第四步，将计算后的结果1 putstatic，最后 counter=1；

以上两个线程共做了两次自增，但最后counter=1，这显然是不合理的，这是因为多线程访问共享资源，由于操作的非原子性导致的数据不一致问题。

```java
public class Demo {

    private static int counter = 0;

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 10000; i++) {
                counter++;
            }
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 10000; i++) {
                counter++;
            }
        });

        t1.start();
        t2.start();
        t1.join();
        t2.join();

        System.out.println(counter);
    }
}
```

创建两个线程，分别做10000次自增，最后获取结果，根据上面得出的结论，最终结果应该是20000，但实际的值一般都会小于20000。（注：循环次数最好大一些，性能比较好的机器运算比较快，循环次数少的话可能看不出效果）

为了解决上面出现的不合理情况，引入了锁的概念，锁的适用场景不同，又可分为很多类型。（接着往下看）


<br/>

## 1. 锁的分类

是否对共享资源加锁，分为：**悲观锁**和**乐观锁**；

是否可重新获取锁，分为：**可重入锁**和**不可重入锁**；

锁竞争的公平性，分为：**公平锁**和**非公平锁**；

多线程是否可共享锁，分为：**共享锁**和**排它锁（独占锁）**；

等等...


<br/>

## 2. 悲观锁

悲观锁策略是认为共享资源一定会存在被其它线程修改的可能，所以会对共享资源加锁。只有持有锁的线程才能执行临界区代码（对共享资源进行读写操作的代码），没有持有锁的线程当访问到临界区代码时会被阻塞住，当锁被持有者释放时，阻塞的线程才会重新进入可运行状态竞争锁。

### 2.1 synchronized

#### 2.1.1 synchronized

`synchronized` 是 Java 提供的关键字，它属于悲观锁，也叫对象锁（为什么叫对象锁后面再说），用来锁住操作共享资源的代码，只有持有对象锁的线程才能执行临界区的代码，其它线程访问到临界区时会被阻塞，当锁的持有者执行完临界区代码后，锁会被释放，被阻塞的线程再重新竞争锁。使用具体代码举例：

```java
public class Demo {

    private static int counter = 0;
    private static Object lock = new Object(); // 锁对象

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 10000; i++) {
                synchronized (lock) { // 临界区代码块，内部的代码块是原子操作
                    counter++;
                }
            }
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 10000; i++) {
                synchronized (lock) {
                    counter++;
                }
            }
        });

        t1.start();
        t2.start();
        t1.join();
        t2.join();

        System.out.println(counter);
    }
}
```

使用 `synchronized` 关键字来锁住 counter++，并发环境下，即使当前线程时间片到期，一次自增没有执行完，其它线程拿到时间片，由于没有对象锁，也会被阻塞，直到当前线程执行完一次自增，锁才会被释放。这其实是保证了临界区代码的原子性。

知道 synchronized 的用处之后，再来说它为什么叫对象锁？从上面的示例代码中可以看到，在类成员中声明了一个 `Object lock = new Object();`，synchronized 需要一个对象来加锁，这个对象的对象头中记录了这个锁被哪个线程持有，具体是怎么记录的后面会详细地说。

synchronized 除了可以锁代码块，还可以直接加到方法上：

```java
public synchronized void increment() {
    // 临界区
}
```

等价于：

```java
public void increment() {
    synchronized (lock) {
        // 临界区
    }
}
```

:::tip
注：如果有多个方法操作同一个共享资源，synchronized 的锁对象应该是相同的对象。
:::


|位置|锁对象|
|--|--|
|代码块|需要指定锁对象|
|成员方法|锁对象是当前对象，也就是this|
|静态方法|锁对象是当前类的类对象，类.class|

<br/>

**synchronized 对象锁还具有**：

1. 重入性；
2. 排他性；

重入性：获取该对象锁的线程，可以在访问被该对象锁保护的其它代码块时再次获取该对象锁。这里面有一个获取锁的计数器，获取锁时计数器+1，执行完一个被保护的代码块后计数器-1，知道计数器为0时该线程释放锁。重入锁是为了防止发生死锁。

排他性：多个线程不会共享同一个锁，当一个线程获得锁，其它线程访问临界区只能被阻塞；

<br/>

#### 2.1.2 Java 对象头

synchronized 在 jdk 1.6 之前使用重量级锁，使用的是操作系统提供的管程（Monitor）实现的，所以会发生用户态与内核态（操作系统执行的代码在内核态）的频繁切换，造成大量的性能损耗；在 jdk 1.6 时对 synchronized 做了优化。因为不是在任何情况下都会发生线程竞争的情况，所以，引入了偏向锁、轻量级锁。

对象锁有四种锁标志：无锁、偏向锁、轻量级锁和重量级锁。

这四种状态记录在哪呢？就记录在锁对象的对象头中，任何对象都有一个对象头信息，下面来认识一下对象头。以 Hotspot 虚拟机为例，Hopspot 对象头主要包括两部分数据：Mark Word（标记字段） 和 class Pointer（类型指针）。

- Mark Word（标记字段），主要记录对象的 Hashcode、分代年龄、锁标志位等信息；
- class Pointer（类型指针），对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

<ImgBox src="https://images.shiguangping.com/imgs/eaf81a4c510fd9f943534d9a8489382f2934a423.jpeg" />

<ImgBox src="https://images.shiguangping.com/imgs/5366d0160924ab18e6cf093c905e0ac87a890b0e.jpeg" />


这里主要看 Mark Word 这部分：

<ImgBox src="https://images.shiguangping.com/imgs/ac4bd11373f08202c1966cfaeb5f17e8aa641b1d.jpeg" />

锁标志就存在锁对象对象头的 Mark Word 中。

<br/>

#### 2.1.3 偏向锁

因为不是所有的时候都会发生线程竞争的情况，如果使用操作系统的管程（Monitor）会显得稍重一些，会发生用户态与内核态的切换，考虑到这一点，在 Jdk 1.6 为 synchronized 引入了偏向锁，偏向锁是考虑到在没有线程竞争的场景下。如果发生了线程竞争的情况，偏向锁会被撤销，从而升级成轻量锁。

<SvgBox src="https://images.shiguangping.com/imgs/%E8%8E%B7%E5%8F%96%E5%81%8F%E5%90%91%E9%94%81.svg" />



<br/>

### 2.2 ReentrantLock