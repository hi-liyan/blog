---
id: design-pattern
title: 设计模式（Java语言描述）
---
import TipBox from "../../src/components/TipBox";
import MarkPen from "../../src/components/MarkPen";

<TipBox>
  本文根据读 刘韬 的《秒懂设计模式》 编写。
</TipBox>

## 1. 创建型
### 1.1 单例模式

单例模式是比较常见的设计模式之一，单例即单一的实例。确切地讲在某个系统中只存在一个实例，同时提供集中、统一的访问接口，以使系统行为保持一致。singleton一词在逻辑学中指“有且仅有一个元素的集合”，这非常恰当地概括了单例的概念，也就是“一个类仅有一个实例”。

应用场景：
 - 一般用在系统中的唯一资源管理上，使用单例模式，例如数据库连接对象，全局维护一个连接对象即可。

缺点：
  - 不适于扩展，扩展只能修改代码；
  - 类的职责过重，一定程度上违背了“单一职责原则”。


单例模式有“饿汉式”和“懒汉式”两种，饿汉式指在类加载时实例化单例对象，懒汉式指在第一次获取实例对象时实例化。

下面通过代码认识“饿汉式”和“懒汉式”这两种单例模式的实现方式。

#### 1.1.1 饿汉式单例模式

饿汉式指在类加载时实例化对象。

```java
/**
 * <p>单例模式：饿汉式（类加载时实例化类实例）</p>
 * <p>在类加载时实例化，不存在并发问题。</p>
 * @author liyan
 * @since 2021-10-18 15:56
 */
public class Sun {
    /**
     * <p>私有的：不允许外部直接访问</p>
     * <p>static：类加载时实例化，永驻内存</p>
     * <p>final：不可变，实例唯一</p>
     */
    private static final Sun sun = new Sun();

    /**
     * 私有化构造函数，不允许外部直接实例化
     */
    private Sun() {}

    /**
     * 提供公共静态方法，获取唯一实例
     * @return Sun
     */
    public static Sun getInstance() {
        return sun;
    }
}
```

#### 1.1.2 懒汉式

懒汉式是在第一次获取实例对象时实例化的。它和饿汉式的不同在于，它是在用到的时候才实例化，避免资源占用，也正因如此，第一次获取实例对象时有个实例化个过程，相对耗时，但这种耗时是可以忽略不计的。

由于懒汉式的实例化过程放在获取实例的方法中，通过判断实例对象是否为null来决定是否需要实例化，这在多线程并发访问时存在缺陷。

```java
/**
 * <p>单例模式：懒汉式（在第一次调用get方法时实例化）</p>
 * <p>因为是在第一次调用get方法时实例化，在多线程环境下存在并发问题，在get方法内加锁。</p>
 *
 * @author liyan
 * @since 2021-10-18 15:56
 */
public class Sun {
    /**
     * <p>private：不允许外部直接访问</p>
     * <p>static：类成员变量</p>
     * <p>volatile：修饰静态变量，保证变量值在各线程访问时的同步性、唯一性</p>
     */
    private static volatile Sun sun = null;

    /**
     * 私有化构造函数，不允许外部直接实例化
     */
    private Sun() {
    }

    /**
     * 提供公共静态方法，获取唯一实例
     *
     * @return Sun
     */
    public static Sun getInstance() {
        if (sun == null) {
            synchronized (Sun.class) {
                if (sun == null) {
                    sun = new Sun();
                }
            }
        }
        return sun;
    }
}
```

#### 1.1.3 大道至简
相对于“懒汉式”，多数时候都是用地“饿汉式”，原因在于一般使用单例模式的对象都会被用到，迟早会被加载进内存，延迟懒加载的意义并不大。懒汉模式中的加锁反而是一种资源浪费，同步更是会降低CPU的利用率，使用不当的话反而会带来不必要的风险。<MarkPen color='null' underline>越简单的包容性越强，而越复杂的反而越容易出错</MarkPen>。

### 1.2 原型模式