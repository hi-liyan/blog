---
title: 'wasm-bindgen'
sidebar_label: wasm-bindgen
---

[`wasm-bindgen`](https://github.com/rustwasm/wasm-bindgen) is a library and tool to facilitate
high-level interactions between Wasm modules and JavaScript; it is built with Rust by
[The Rust and WebAssembly Working Group](https://rustwasm.github.io/).

[`wasm-bindgen`](https://github.com/rustwasm/wasm-bindgen) 是一个由 [Rust 和 WebAssembly 工作组](https://rustwasm.github.io/)创建的库和工具，旨在促进 Wasm 模块和 JavaScript 之间的高级交互。

Yew 使用 `wasm-bindgen` 来与浏览器进行交互通过一系列 creates：

-   [`js-sys`](https://crates.io/crates/js-sys)
-   [`wasm-bindgen`](https://crates.io/crates/wasm-bindgen)
-   [`wasm-bindgen-futures`](https://crates.io/crates/wasm-bindgen-futures)
-   [`web-sys`](https://crates.io/crates/web-sys)

本节将从高层次上探讨其中一些包，以便更容易地理解和使用与 Yew 相关的 `wasm-bindgen` API。如需更深入地了解 `wasm-bindgen` 及其相关的包，请查看 [wasm-bindgen 指南](https://rustwasm.github.io/docs/wasm-bindgen/)。

要查看上述 crates 的文档，请查看 [`wasm-bindgen docs.rs`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/index.html)。

:::tip
使用 `wasm-bindgen` 的 doc.rs 搜索功能，可以找到已经通过 `wasm-bindgen` 导入的浏览器 API 和 JavaScript 类型。
:::

## [`wasm-bindgen`](https://crates.io/crates/wasm-bindgen)

该库为上述其他 crate 提供了许多构建块。在本节中，我们只会涵盖 `wasm-bindgen` crate 的两个主要方面，即宏和一些你会一遍又一遍看到的类型/特性。

### `#[wasm_bindgen]` 宏

`#[wasm_bindgen]` 宏提供了 Rust 和 JavaScript 之间的接口，为它们之间的相互转换提供了一个系统。
使用这个宏比较高级，除非你想使用一个外部的 JavaScript 库，否则不应该使用它。`js-sys` 和 `web-sys` crate
提供了针对内置 JavaScript 类型和浏览器 API 的 `wasm-bindgen` 定义。

让我们通过一个简单的例子来使用 `#[wasm-bindgen]` 宏导入一些特定版本的 [`console.log`](https://developer.mozilla.org/en-US/docs/Web/API/Console/log) 函数。

```rust ,no_run
use wasm_bindgen::prelude::*;

// 首先，让我们手动绑定console.log，而不使用web_sys的帮助。
// 在这里，我们手动编写#[wasm_bindgen]注释，我们程序的正确性取决于这些注释的正确性！
#[wasm_bindgen]
extern "C" {

    // 在这里使用 `js_namespace` 来绑定 `console.log（..）` 而不是仅绑定 `log（..）`
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);

    // `console.log` 具有多种形式，因此我们可以绑定多个签名。
    // 请注意，我们需要使用 `js_name`，以确保我们始终在 JS 中调用 `log`。
    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn log_u32(a: u32);

    // 多个参数也是如此!
    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn log_many(a: &str, b: &str);
}

// 使用导入的函数！
log("Hello from Rust!");
log_u32(42);
log_many("Logging", "many values!");
```
_这个例子修改自 [1.2 Using console.log of The `wasm-bindgen` Guide](https://rustwasm.github.io/docs/wasm-bindgen/examples/console-log.html)。_

### Simulating inheritance

JavaScript 类之间的继承是 JavaScript 语言的一个核心特性，DOM（文档对象模型）就是围绕它设计的。当使用 `wasm-bindgen` 导入类型时，您还可以添加描述其继承关系的属性。

在Rust中，这种继承关系使用 [`Deref`](https://doc.rust-lang.org/std/ops/trait.Deref.html) 和 [`AsRef`](https://doc.rust-lang.org/std/convert/trait.AsRef.html) trait 来表示。举个例子，假设你有三个类型 `A`，`B` 和 `C`，其中 `C` 扩展 `B`，而 `B` 又扩展 `A`。

当导入这些类型时，`#[wasm-bindgen]` 宏将以以下方式实现 `Deref` 和 `AsRef` 特征：

-   `C` 可以 `Deref` 到 `B`
-   `B` 可以 `Deref` 到 `A`
-   `C` 可以作为 `AsRef` 传递给 `B`
-   `C` & `B` 都可以作为 `AsRef` 传递给 `A`

这些实现使您能够在 `C` 的实例上调用 `A` 的方法，并将 `C` 用作 `&B` 或 `&A` 一样使用。

这里需要注意的是，每个使用 `#[wasm-bindgen]` 导入的类型都有相同的根类型，可以将其看作是上面示例中的 `A`，这个类型是 [`JsValue`](#jsvalue)，将在下面的章节中介绍。

_[extends section in The `wasm-bindgen` Guide](https://rustwasm.github.io/docs/wasm-bindgen/reference/attributes/on-js-imports/extends.html)_

### [`JsValue`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/struct.JsValue.html) {#jsvalue}

JsValue 是一个由 JavaScript 拥有的对象的表示，它是 `wasm-bindgen` 的一个根基础类型。所有来自 `wasm-bindgen` 的类型都是 `JsValue` 类型，
这是因为 JavaScript 没有一个强类型系统，所以任何接受一个名为 `x` 的变量的函数并不定义它的类型，因此 `x` 可以是一个有效的 JavaScript 值；因此使用 `JsValue`。
如果您正在使用接受 `JsValue` 的导入函数或类型，那么任何导入的值都是 _技术上_ 有效的。

`JsValue` 可以被函数接受，但是这个函数仍然可能只接受特定的类型，这可能导致 panic - 因此，在使用原始的 `wasm-bindgen` API 时，
需要检查导入的 JavaScript 的文档，以确定如果该值不是某种类型是否会引发异常 (panic)。

_[`JsValue` documentation](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/struct.JsValue.html)._

### [`JsCast`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/trait.JsCast.html) {#JsCast}

Rust has a strong type system and JavaScript...doesn't 😞. For Rust to maintain these
strong types but still be convenient, the WebAssembly group came up with a pretty neat trait `JsCast`.
Its job is to help you move from one JavaScript "type" to another, which sounds vague, but it means
that if you have one type which you know is another, then you can use the functions of `JsCast`
to jump from one type to the other. It is a nice trait to get to know when working with `web-sys`,
`wasm_bindgen`, `js-sys` - you will notice lots of types will implement `JsCast` from those crates.

`JsCast` provides both checked and unchecked methods of casting - so that at runtime if you are
unsure what type a certain object is you can try to cast it which returns possible failure types like
[`Option`](https://doc.rust-lang.org/std/option/enum.Option.html) and
[`Result`](https://doc.rust-lang.org/std/result/enum.Result.html).

A common example of this in [`web-sys`](./web-sys.mdx) is when you are trying to get the
target of an event. You might know what the target element is but the
[`web_sys::Event`](https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Event.html) API will always return an [`Option<web_sys::EventTarget>`](https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Event.html#method.target).
You will need to cast it to the element type so you can call its methods.

```rust
// need to import the trait.
use wasm_bindgen::JsCast;
use web_sys::{Event, EventTarget, HtmlInputElement, HtmlSelectElement};

fn handle_event(event: Event) {
    let target: EventTarget = event
        .target()
        .expect("I'm sure this event has a target!");

    // maybe the target is a select element?
    if let Some(select_element) = target.dyn_ref::<HtmlSelectElement>() {
        // do something amazing here
        return;
    }

    // if it wasn't a select element then I KNOW it's a input element!
    let input_element: HtmlInputElement = target.unchecked_into();
}
```

The [`dyn_ref`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/trait.JsCast.html#method.dyn_ref)
method is a checked cast that returns an `Option<&T>` which means the original type
can be used again if the cast failed and thus returned `None`. The
[`dyn_into`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/trait.JsCast.html#method.dyn_into)
method will consume `self`, as per convention for `into` methods in Rust, and the type returned is
`Result<T, Self>`. If the casting fails, the original `Self` value is returned in `Err`. You can try again
or do something else with the original type.

_[`JsCast` documentation](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/trait.JsCast.html)._

### [`Closure`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/closure/struct.Closure.html)

The `Closure` type provides a way to transfer Rust closures to JavaScript, the closures passed to
JavaScript must have a `'static` lifetime for soundness reasons.

This type is a "handle" in the sense that whenever it is dropped it will invalidate the JS
closure that it refers to. Any usage of the closure in JS after the Closure has been dropped will
raise an exception.

`Closure` is often used when you are working with a `js-sys` or `web-sys` API that accepts a type
[`&js_sys::Function`](https://rustwasm.github.io/wasm-bindgen/api/js_sys/struct.Function.html).
An example of using a `Closure` in Yew can be found in the [Using `Closure` section](../html/events.mdx#using-closure-verbose)
on the [Events](../html/events.mdx) page.

_[`Closure` documentation](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/closure/struct.Closure.html)._

## [`js-sys`](https://crates.io/crates/js-sys)

The `js-sys` crate provides bindings/imports of JavaScript's standard, built-in objects, including
their methods and properties.

This does not include any web APIs as this is what [`web-sys`](./web-sys.mdx) is for!

_[`js-sys` documentation](https://rustwasm.github.io/wasm-bindgen/api/js_sys/index.html)._

## [`wasm-bindgen-futures`](https://crates.io/crates/wasm-bindgen-futures)

The `wasm-bindgen-futures` crate provides a bridge for working with JavaScript Promise types as a
Rust [`Future`](https://doc.rust-lang.org/stable/std/future/trait.Future.html), and contains
utilities to turn a rust Future into a JavaScript Promise. This can be useful when working with
asynchronous or otherwise blocking work in Rust (wasm), and provides the ability to interoperate
with JavaScript events and JavaScript I/O primitives.

There are three main interfaces in this crate currently:

1. [`JsFuture`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen_futures/struct.JsFuture.html) -
   A type that is constructed with a [`Promise`](https://rustwasm.github.io/wasm-bindgen/api/js_sys/struct.Promise.html)
   and can then be used as a `Future<Output=Result<JsValue, JsValue>>`. This `Future` will resolve to `Ok` if
   the `Promise` is resolved and `Err` if the `Promise` is rejected, containing the resolved or rejected
   value from the `Promise` respectively.

2. [`future_to_promise`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen_futures/fn.future_to_promise.html) -
   Converts a Rust `Future<Output=Result<JsValue, JsValue>>` into a
   JavaScript `Promise`. The future’s result will translate to either a resolved or rejected
   `Promise` in JavaScript.

3. [`spawn_local`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen_futures/fn.spawn_local.html) -
   Spawns a `Future<Output = ()>` on the current thread. This is the best way
   to run a Future in Rust without sending it to JavaScript.

_[`wasm-bindgen-futures` documentation](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen_futures/index.html)._

### [`spawn_local`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen_futures/fn.spawn_local.html)

`spawn_local` is going to be the most commonly used part of the `wasm-bindgen-futures` crate in Yew
as this helps when using libraries that have async APIs.

```rust ,no_run
use web_sys::console;
use wasm_bindgen_futures::spawn_local;

async fn my_async_fn() -> String { String::from("Hello") }

spawn_local(async {
    let mut string = my_async_fn().await;
    string.push_str(", world!");
    // console log "Hello, world!"
    console::log_1(&string.into());
});
```

Yew has also added support for futures in certain APIs, most notably you can create a
`callback_future` which accepts an `async` block - this uses `spawn_local` internally.

_[`spawn_local` documentation](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen_futures/fn.spawn_local.html)._
