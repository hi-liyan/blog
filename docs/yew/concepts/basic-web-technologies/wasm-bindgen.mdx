---
title: 'wasm-bindgen'
sidebar_label: wasm-bindgen
---

[`wasm-bindgen`](https://github.com/rustwasm/wasm-bindgen) is a library and tool to facilitate
high-level interactions between Wasm modules and JavaScript; it is built with Rust by
[The Rust and WebAssembly Working Group](https://rustwasm.github.io/).

[`wasm-bindgen`](https://github.com/rustwasm/wasm-bindgen) æ˜¯ä¸€ä¸ªç”± [Rust å’Œ WebAssembly å·¥ä½œç»„](https://rustwasm.github.io/)åˆ›å»ºçš„åº“å’Œå·¥å…·ï¼Œæ—¨åœ¨ä¿ƒè¿› Wasm æ¨¡å—å’Œ JavaScript ä¹‹é—´çš„é«˜çº§äº¤äº’ã€‚

Yew ä½¿ç”¨ `wasm-bindgen` æ¥ä¸æµè§ˆå™¨è¿›è¡Œäº¤äº’é€šè¿‡ä¸€ç³»åˆ— createsï¼š

-   [`js-sys`](https://crates.io/crates/js-sys)
-   [`wasm-bindgen`](https://crates.io/crates/wasm-bindgen)
-   [`wasm-bindgen-futures`](https://crates.io/crates/wasm-bindgen-futures)
-   [`web-sys`](https://crates.io/crates/web-sys)

æœ¬èŠ‚å°†ä»é«˜å±‚æ¬¡ä¸Šæ¢è®¨å…¶ä¸­ä¸€äº›åŒ…ï¼Œä»¥ä¾¿æ›´å®¹æ˜“åœ°ç†è§£å’Œä½¿ç”¨ä¸ Yew ç›¸å…³çš„ `wasm-bindgen` APIã€‚å¦‚éœ€æ›´æ·±å…¥åœ°äº†è§£ `wasm-bindgen` åŠå…¶ç›¸å…³çš„åŒ…ï¼Œè¯·æŸ¥çœ‹ [wasm-bindgen æŒ‡å—](https://rustwasm.github.io/docs/wasm-bindgen/)ã€‚

è¦æŸ¥çœ‹ä¸Šè¿° crates çš„æ–‡æ¡£ï¼Œè¯·æŸ¥çœ‹ [`wasm-bindgen docs.rs`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/index.html)ã€‚

:::tip
ä½¿ç”¨ `wasm-bindgen` çš„ doc.rs æœç´¢åŠŸèƒ½ï¼Œå¯ä»¥æ‰¾åˆ°å·²ç»é€šè¿‡ `wasm-bindgen` å¯¼å…¥çš„æµè§ˆå™¨ API å’Œ JavaScript ç±»å‹ã€‚
:::

## [`wasm-bindgen`](https://crates.io/crates/wasm-bindgen)

è¯¥åº“ä¸ºä¸Šè¿°å…¶ä»– crate æä¾›äº†è®¸å¤šæ„å»ºå—ã€‚åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬åªä¼šæ¶µç›– `wasm-bindgen` crate çš„ä¸¤ä¸ªä¸»è¦æ–¹é¢ï¼Œå³å®å’Œä¸€äº›ä½ ä¼šä¸€éåˆä¸€éçœ‹åˆ°çš„ç±»å‹/ç‰¹æ€§ã€‚

### `#[wasm_bindgen]` å®

`#[wasm_bindgen]` å®æä¾›äº† Rust å’Œ JavaScript ä¹‹é—´çš„æ¥å£ï¼Œä¸ºå®ƒä»¬ä¹‹é—´çš„ç›¸äº’è½¬æ¢æä¾›äº†ä¸€ä¸ªç³»ç»Ÿã€‚
ä½¿ç”¨è¿™ä¸ªå®æ¯”è¾ƒé«˜çº§ï¼Œé™¤éä½ æƒ³ä½¿ç”¨ä¸€ä¸ªå¤–éƒ¨çš„ JavaScript åº“ï¼Œå¦åˆ™ä¸åº”è¯¥ä½¿ç”¨å®ƒã€‚`js-sys` å’Œ `web-sys` crate
æä¾›äº†é’ˆå¯¹å†…ç½® JavaScript ç±»å‹å’Œæµè§ˆå™¨ API çš„ `wasm-bindgen` å®šä¹‰ã€‚

è®©æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªç®€å•çš„ä¾‹å­æ¥ä½¿ç”¨ `#[wasm-bindgen]` å®å¯¼å…¥ä¸€äº›ç‰¹å®šç‰ˆæœ¬çš„ [`console.log`](https://developer.mozilla.org/en-US/docs/Web/API/Console/log) å‡½æ•°ã€‚

```rust ,no_run
use wasm_bindgen::prelude::*;

// é¦–å…ˆï¼Œè®©æˆ‘ä»¬æ‰‹åŠ¨ç»‘å®šconsole.logï¼Œè€Œä¸ä½¿ç”¨web_sysçš„å¸®åŠ©ã€‚
// åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬æ‰‹åŠ¨ç¼–å†™#[wasm_bindgen]æ³¨é‡Šï¼Œæˆ‘ä»¬ç¨‹åºçš„æ­£ç¡®æ€§å–å†³äºè¿™äº›æ³¨é‡Šçš„æ­£ç¡®æ€§ï¼
#[wasm_bindgen]
extern "C" {

    // åœ¨è¿™é‡Œä½¿ç”¨ `js_namespace` æ¥ç»‘å®š `console.logï¼ˆ..ï¼‰` è€Œä¸æ˜¯ä»…ç»‘å®š `logï¼ˆ..ï¼‰`
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);

    // `console.log` å…·æœ‰å¤šç§å½¢å¼ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç»‘å®šå¤šä¸ªç­¾åã€‚
    // è¯·æ³¨æ„ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨ `js_name`ï¼Œä»¥ç¡®ä¿æˆ‘ä»¬å§‹ç»ˆåœ¨ JS ä¸­è°ƒç”¨ `log`ã€‚
    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn log_u32(a: u32);

    // å¤šä¸ªå‚æ•°ä¹Ÿæ˜¯å¦‚æ­¤!
    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn log_many(a: &str, b: &str);
}

// ä½¿ç”¨å¯¼å…¥çš„å‡½æ•°ï¼
log("Hello from Rust!");
log_u32(42);
log_many("Logging", "many values!");
```
_è¿™ä¸ªä¾‹å­ä¿®æ”¹è‡ª [1.2 Using console.log of The `wasm-bindgen` Guide](https://rustwasm.github.io/docs/wasm-bindgen/examples/console-log.html)ã€‚_

### Simulating inheritance

JavaScript ç±»ä¹‹é—´çš„ç»§æ‰¿æ˜¯ JavaScript è¯­è¨€çš„ä¸€ä¸ªæ ¸å¿ƒç‰¹æ€§ï¼ŒDOMï¼ˆæ–‡æ¡£å¯¹è±¡æ¨¡å‹ï¼‰å°±æ˜¯å›´ç»•å®ƒè®¾è®¡çš„ã€‚å½“ä½¿ç”¨ `wasm-bindgen` å¯¼å…¥ç±»å‹æ—¶ï¼Œæ‚¨è¿˜å¯ä»¥æ·»åŠ æè¿°å…¶ç»§æ‰¿å…³ç³»çš„å±æ€§ã€‚

åœ¨Rustä¸­ï¼Œè¿™ç§ç»§æ‰¿å…³ç³»ä½¿ç”¨ [`Deref`](https://doc.rust-lang.org/std/ops/trait.Deref.html) å’Œ [`AsRef`](https://doc.rust-lang.org/std/convert/trait.AsRef.html) trait æ¥è¡¨ç¤ºã€‚ä¸¾ä¸ªä¾‹å­ï¼Œå‡è®¾ä½ æœ‰ä¸‰ä¸ªç±»å‹ `A`ï¼Œ`B` å’Œ `C`ï¼Œå…¶ä¸­ `C` æ‰©å±• `B`ï¼Œè€Œ `B` åˆæ‰©å±• `A`ã€‚

å½“å¯¼å…¥è¿™äº›ç±»å‹æ—¶ï¼Œ`#[wasm-bindgen]` å®å°†ä»¥ä»¥ä¸‹æ–¹å¼å®ç° `Deref` å’Œ `AsRef` ç‰¹å¾ï¼š

-   `C` å¯ä»¥ `Deref` åˆ° `B`
-   `B` å¯ä»¥ `Deref` åˆ° `A`
-   `C` å¯ä»¥ä½œä¸º `AsRef` ä¼ é€’ç»™ `B`
-   `C` & `B` éƒ½å¯ä»¥ä½œä¸º `AsRef` ä¼ é€’ç»™ `A`

è¿™äº›å®ç°ä½¿æ‚¨èƒ½å¤Ÿåœ¨ `C` çš„å®ä¾‹ä¸Šè°ƒç”¨ `A` çš„æ–¹æ³•ï¼Œå¹¶å°† `C` ç”¨ä½œ `&B` æˆ– `&A` ä¸€æ ·ä½¿ç”¨ã€‚

è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæ¯ä¸ªä½¿ç”¨ `#[wasm-bindgen]` å¯¼å…¥çš„ç±»å‹éƒ½æœ‰ç›¸åŒçš„æ ¹ç±»å‹ï¼Œå¯ä»¥å°†å…¶çœ‹ä½œæ˜¯ä¸Šé¢ç¤ºä¾‹ä¸­çš„ `A`ï¼Œè¿™ä¸ªç±»å‹æ˜¯ [`JsValue`](#jsvalue)ï¼Œå°†åœ¨ä¸‹é¢çš„ç« èŠ‚ä¸­ä»‹ç»ã€‚

_[extends section in The `wasm-bindgen` Guide](https://rustwasm.github.io/docs/wasm-bindgen/reference/attributes/on-js-imports/extends.html)_

### [`JsValue`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/struct.JsValue.html) {#jsvalue}

JsValue æ˜¯ä¸€ä¸ªç”± JavaScript æ‹¥æœ‰çš„å¯¹è±¡çš„è¡¨ç¤ºï¼Œå®ƒæ˜¯ `wasm-bindgen` çš„ä¸€ä¸ªæ ¹åŸºç¡€ç±»å‹ã€‚æ‰€æœ‰æ¥è‡ª `wasm-bindgen` çš„ç±»å‹éƒ½æ˜¯ `JsValue` ç±»å‹ï¼Œ
è¿™æ˜¯å› ä¸º JavaScript æ²¡æœ‰ä¸€ä¸ªå¼ºç±»å‹ç³»ç»Ÿï¼Œæ‰€ä»¥ä»»ä½•æ¥å—ä¸€ä¸ªåä¸º `x` çš„å˜é‡çš„å‡½æ•°å¹¶ä¸å®šä¹‰å®ƒçš„ç±»å‹ï¼Œå› æ­¤ `x` å¯ä»¥æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„ JavaScript å€¼ï¼›å› æ­¤ä½¿ç”¨ `JsValue`ã€‚
å¦‚æœæ‚¨æ­£åœ¨ä½¿ç”¨æ¥å— `JsValue` çš„å¯¼å…¥å‡½æ•°æˆ–ç±»å‹ï¼Œé‚£ä¹ˆä»»ä½•å¯¼å…¥çš„å€¼éƒ½æ˜¯ _æŠ€æœ¯ä¸Š_ æœ‰æ•ˆçš„ã€‚

`JsValue` å¯ä»¥è¢«å‡½æ•°æ¥å—ï¼Œä½†æ˜¯è¿™ä¸ªå‡½æ•°ä»ç„¶å¯èƒ½åªæ¥å—ç‰¹å®šçš„ç±»å‹ï¼Œè¿™å¯èƒ½å¯¼è‡´ panic - å› æ­¤ï¼Œåœ¨ä½¿ç”¨åŸå§‹çš„ `wasm-bindgen` API æ—¶ï¼Œ
éœ€è¦æ£€æŸ¥å¯¼å…¥çš„ JavaScript çš„æ–‡æ¡£ï¼Œä»¥ç¡®å®šå¦‚æœè¯¥å€¼ä¸æ˜¯æŸç§ç±»å‹æ˜¯å¦ä¼šå¼•å‘å¼‚å¸¸ (panic)ã€‚

_[`JsValue` documentation](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/struct.JsValue.html)._

### [`JsCast`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/trait.JsCast.html) {#JsCast}

Rust has a strong type system and JavaScript...doesn't ğŸ˜. For Rust to maintain these
strong types but still be convenient, the WebAssembly group came up with a pretty neat trait `JsCast`.
Its job is to help you move from one JavaScript "type" to another, which sounds vague, but it means
that if you have one type which you know is another, then you can use the functions of `JsCast`
to jump from one type to the other. It is a nice trait to get to know when working with `web-sys`,
`wasm_bindgen`, `js-sys` - you will notice lots of types will implement `JsCast` from those crates.

`JsCast` provides both checked and unchecked methods of casting - so that at runtime if you are
unsure what type a certain object is you can try to cast it which returns possible failure types like
[`Option`](https://doc.rust-lang.org/std/option/enum.Option.html) and
[`Result`](https://doc.rust-lang.org/std/result/enum.Result.html).

A common example of this in [`web-sys`](./web-sys.mdx) is when you are trying to get the
target of an event. You might know what the target element is but the
[`web_sys::Event`](https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Event.html) API will always return an [`Option<web_sys::EventTarget>`](https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Event.html#method.target).
You will need to cast it to the element type so you can call its methods.

```rust
// need to import the trait.
use wasm_bindgen::JsCast;
use web_sys::{Event, EventTarget, HtmlInputElement, HtmlSelectElement};

fn handle_event(event: Event) {
    let target: EventTarget = event
        .target()
        .expect("I'm sure this event has a target!");

    // maybe the target is a select element?
    if let Some(select_element) = target.dyn_ref::<HtmlSelectElement>() {
        // do something amazing here
        return;
    }

    // if it wasn't a select element then I KNOW it's a input element!
    let input_element: HtmlInputElement = target.unchecked_into();
}
```

The [`dyn_ref`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/trait.JsCast.html#method.dyn_ref)
method is a checked cast that returns an `Option<&T>` which means the original type
can be used again if the cast failed and thus returned `None`. The
[`dyn_into`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/trait.JsCast.html#method.dyn_into)
method will consume `self`, as per convention for `into` methods in Rust, and the type returned is
`Result<T, Self>`. If the casting fails, the original `Self` value is returned in `Err`. You can try again
or do something else with the original type.

_[`JsCast` documentation](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/trait.JsCast.html)._

### [`Closure`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/closure/struct.Closure.html)

The `Closure` type provides a way to transfer Rust closures to JavaScript, the closures passed to
JavaScript must have a `'static` lifetime for soundness reasons.

This type is a "handle" in the sense that whenever it is dropped it will invalidate the JS
closure that it refers to. Any usage of the closure in JS after the Closure has been dropped will
raise an exception.

`Closure` is often used when you are working with a `js-sys` or `web-sys` API that accepts a type
[`&js_sys::Function`](https://rustwasm.github.io/wasm-bindgen/api/js_sys/struct.Function.html).
An example of using a `Closure` in Yew can be found in the [Using `Closure` section](../html/events.mdx#using-closure-verbose)
on the [Events](../html/events.mdx) page.

_[`Closure` documentation](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/closure/struct.Closure.html)._

## [`js-sys`](https://crates.io/crates/js-sys)

The `js-sys` crate provides bindings/imports of JavaScript's standard, built-in objects, including
their methods and properties.

This does not include any web APIs as this is what [`web-sys`](./web-sys.mdx) is for!

_[`js-sys` documentation](https://rustwasm.github.io/wasm-bindgen/api/js_sys/index.html)._

## [`wasm-bindgen-futures`](https://crates.io/crates/wasm-bindgen-futures)

The `wasm-bindgen-futures` crate provides a bridge for working with JavaScript Promise types as a
Rust [`Future`](https://doc.rust-lang.org/stable/std/future/trait.Future.html), and contains
utilities to turn a rust Future into a JavaScript Promise. This can be useful when working with
asynchronous or otherwise blocking work in Rust (wasm), and provides the ability to interoperate
with JavaScript events and JavaScript I/O primitives.

There are three main interfaces in this crate currently:

1. [`JsFuture`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen_futures/struct.JsFuture.html) -
   A type that is constructed with a [`Promise`](https://rustwasm.github.io/wasm-bindgen/api/js_sys/struct.Promise.html)
   and can then be used as a `Future<Output=Result<JsValue, JsValue>>`. This `Future` will resolve to `Ok` if
   the `Promise` is resolved and `Err` if the `Promise` is rejected, containing the resolved or rejected
   value from the `Promise` respectively.

2. [`future_to_promise`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen_futures/fn.future_to_promise.html) -
   Converts a Rust `Future<Output=Result<JsValue, JsValue>>` into a
   JavaScript `Promise`. The futureâ€™s result will translate to either a resolved or rejected
   `Promise` in JavaScript.

3. [`spawn_local`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen_futures/fn.spawn_local.html) -
   Spawns a `Future<Output = ()>` on the current thread. This is the best way
   to run a Future in Rust without sending it to JavaScript.

_[`wasm-bindgen-futures` documentation](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen_futures/index.html)._

### [`spawn_local`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen_futures/fn.spawn_local.html)

`spawn_local` is going to be the most commonly used part of the `wasm-bindgen-futures` crate in Yew
as this helps when using libraries that have async APIs.

```rust ,no_run
use web_sys::console;
use wasm_bindgen_futures::spawn_local;

async fn my_async_fn() -> String { String::from("Hello") }

spawn_local(async {
    let mut string = my_async_fn().await;
    string.push_str(", world!");
    // console log "Hello, world!"
    console::log_1(&string.into());
});
```

Yew has also added support for futures in certain APIs, most notably you can create a
`callback_future` which accepts an `async` block - this uses `spawn_local` internally.

_[`spawn_local` documentation](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen_futures/fn.spawn_local.html)._
